module Halogen.Driver
  ( Driver
  , runUI
  ) where

import Prelude

import Control.Coroutine (await)
import Control.Coroutine.Stalling (($$?))
import Control.Coroutine.Stalling as SCR
import Control.Monad.Aff (Aff, runAff, forkAff)
import Control.Monad.Aff.AVar (AVar, AVAR, makeVar', putVar, takeVar, modifyVar)
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Class (liftEff)
import Control.Monad.Eff.Exception (error, throwException)
import Control.Monad.Error.Class (throwError)
import Control.Monad.Free (foldFree)
import Control.Monad.Rec.Class (forever)
import Control.Monad.Trans (lift)

import Data.Map as M
import Data.Maybe (Maybe(..))
import Data.Lazy (force)

import DOM.HTML.Types (HTMLElement, htmlElementToNode)
import DOM.Node.Node (appendChild)

import Halogen.Component (Component, ParentDSL, ComponentSlot(..), unComponent)
import Halogen.Data.OrdBox (OrdBox, unOrdBox)
import Halogen.Driver.State (DriverStateX, DriverState(..), unDriverStateX, initDriverState)
import Halogen.Effects (HalogenEffects)
import Halogen.HTML.Renderer.VirtualDOM (renderHTML')
import Halogen.Internal.VirtualDOM as V
import Halogen.Query (HalogenF(..))
import Halogen.Query.ChildQuery (ChildQuery, unChildQuery)
import Halogen.Query.EventSource (runEventSource)
import Halogen.Query.StateF (StateF(..))

-- | Type alias for driver functions generated by `runUI` - a driver takes an
-- | input of the query algebra (`f`) and returns an `Aff` that returns when
-- | query has been fulfilled.
type Driver f eff = f ~> Aff (HalogenEffects eff)

type DSL s f f' eff p = ParentDSL s f f' (Aff (HalogenEffects eff)) p

-- | This function is the main entry point for a Halogen based UI, taking a root
-- | component, initial state, and HTML element to attach the rendered component
-- | to.
-- |
-- | The returned "driver" function can be used to send actions and requests
-- | into the component hierarchy, allowing the outside world to communicate
-- | with the UI.
runUI
  :: forall f eff
   . Component f (Aff (HalogenEffects eff))
  -> HTMLElement
  -> Aff (HalogenEffects eff) (Driver f eff)
runUI component element = _.driver <$> do
  var <- runComponent component
  dsx <- peekVar var
  unDriverStateX (\st -> do
    -- TODO: run initializer(s) after element is added to DOM?
    liftEff $ appendChild (htmlElementToNode st.node) (htmlElementToNode element)
    -- The record here is a hack around a skolem escape issue. If the typing
    -- rules for records change so this no longer works it may also be fixable
    -- with copious type annotations.
    pure { driver: evalF st.selfRef }) dsx

runComponent
  :: forall f eff
   . Component f (Aff (HalogenEffects eff))
  -> Aff (HalogenEffects eff) (AVar (DriverStateX f eff))
runComponent = unComponent \component -> do
  var <- initDriverState component
  unDriverStateX (render <<< _.selfRef) =<< peekVar var
  pure var

eval
  :: forall s f g eff p
   . AVar (DriverState s f g eff p)
  -> DSL s f g eff p
  ~> Aff (HalogenEffects eff)
eval ref = case _ of
  State i -> do
    case i of
      Get k -> do
        DriverState st <- peekVar ref
        pure (k st.state)
      Modify f next -> do
        modifyVar (\(DriverState st) -> DriverState (st { state = f st.state })) ref
        render ref
        pure next
  Subscribe es next -> do
    let consumer = forever (lift <<< evalF ref =<< await)
    forkAff $ SCR.runStallingProcess (runEventSource es $$? consumer)
    pure next
  Lift q -> do
    -- render ref -- TODO: is this necessary?
    q
  Halt msg -> do
    throwError (error msg)
  GetSlots k -> do
    DriverState st <- peekVar ref
    pure $ k $ map unOrdBox $ M.keys st.children
  ChildQuery cq ->
    evalChildQuery ref cq

evalChildQuery
  :: forall s f g eff p
   . AVar (DriverState s f g eff p)
  -> ChildQuery g (Aff (HalogenEffects eff)) p
  ~> Aff (HalogenEffects eff)
evalChildQuery ref = unChildQuery \p k -> do
  DriverState st <- peekVar ref
  case M.lookup (st.mkOrdBox p) st.children of
    Just var -> do
      dsx <- peekVar var
      k (unDriverStateX (\ds q -> evalF ds.selfRef q) dsx)
    Nothing -> throwError (error "Slot lookup failed for child query")

evalF
  :: forall s f g eff p
   . AVar (DriverState s f g eff p)
  -> f
  ~> Aff (HalogenEffects eff)
evalF ref q = do
  DriverState st <- peekVar ref
  foldFree (eval ref) (st.component.eval q)

peekVar :: forall eff a. AVar a -> Aff (avar :: AVAR | eff) a
peekVar v = do
  a <- takeVar v
  putVar v a
  pure a

render
  :: forall s f g eff p
   . AVar (DriverState s f g eff p)
  -> Aff (HalogenEffects eff) Unit
render var = takeVar var >>= \(DriverState ds) -> do
  children <- makeVar' (M.empty :: M.Map (OrdBox p) (AVar (DriverStateX g eff)))
  vtree' <-
    renderHTML'
      (handleAff <<< evalF ds.selfRef)
      (renderChild ds.mkOrdBox ds.children children)
      (ds.component.render ds.state)
  node' <- liftEff $ V.patch (V.diff ds.vtree vtree') ds.node
  newChildren <- takeVar children
  -- TODO: diff children, deal with initializers/finalizers
  putVar var $
    DriverState
      { node: node'
      , vtree: vtree'
      , component: ds.component
      , state: ds.state
      , children: newChildren
      , mkOrdBox: ds.mkOrdBox
      , selfRef: ds.selfRef
      }

renderChild
  :: forall g eff p
   . (p -> OrdBox p)
  -> M.Map (OrdBox p) (AVar (DriverStateX g eff))
  -> AVar (M.Map (OrdBox p) (AVar (DriverStateX g eff)))
  -> ComponentSlot g (Aff (HalogenEffects eff)) p
  -> Aff (HalogenEffects eff) V.VTree
renderChild mkOrdBox childrenIn childrenOut (ComponentSlot p ctor) = do
  var <- case M.lookup (mkOrdBox p) childrenIn of
    Just existing -> pure existing
    Nothing -> runComponent (force ctor)
  modifyVar (M.insert (mkOrdBox p) var) childrenOut
  unDriverStateX (\st -> pure $ V.widget st.node) =<< peekVar var

-- | TODO: we could do something more intelligent now this isn't baked into the
-- | virtual-dom rendering. Perhaps write to an avar when an error occurs...
-- | something other than a runtime exception anyway.
handleAff
  :: forall eff a
   . Aff (HalogenEffects eff) a
  -> Eff (HalogenEffects eff) Unit
handleAff = void <<< runAff throwException (const (pure unit))
