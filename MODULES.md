# Module Documentation

## Module Halogen

#### `runUI`

``` purescript
runUI :: forall i eff. Signal1 (dom :: DOM, ref :: Ref | eff) i (HTML i) -> Eff (dom :: DOM, ref :: Ref | eff) Node
```

`runUI` takes a UI represented as a signal function, and renders it to the DOM
using `virtual-dom`.

The signal function is responsible for rendering the HTML for the UI, and the 
HTML can generate inputs which will be fed back into the signal function,
resulting in DOM updates.

This function returns a `Node`, and the caller is responsible for adding the node
to the DOM.

As a simple example, we can create a signal which responds to button clicks:

```purescript
ui :: forall eff. Signal1 eff Unit (HTML Unit)
ui = view <$> stateful 0 (\n _ -> pure (n + 1))
  where
  view :: Number -> HTML Unit
  view n = button [ OnClick (const unit) ] [ text (show n) ]
```


## Module Halogen.HTML

#### `MouseEvent`

``` purescript
data MouseEvent
```


#### `Attribute`

``` purescript
data Attribute i
  = OnClick (MouseEvent -> i)
```

#### `functorAttribute`

``` purescript
instance functorAttribute :: Functor Attribute
```


#### `HTML`

``` purescript
data HTML i
```

The `HTML` type represents HTML documents before being rendered to the virtual DOM, and ultimately,
the actual DOM.

This representation is useful because it supports various typed transformations. It also gives a 
strongly-typed representation for the events which can be generated by a document.

The type parameter `i` represents the type of events which can be generated by this document.

#### `functorHTML`

``` purescript
instance functorHTML :: Functor HTML
```


#### `renderHtml`

``` purescript
renderHtml :: forall i eff. (i -> Eff eff Unit) -> HTML i -> VTree
```

Render a `HTML` document to a virtual DOM node

#### `text`

``` purescript
text :: forall i. String -> HTML i
```


#### `button`

``` purescript
button :: forall i. [Attribute i] -> [HTML i] -> HTML i
```

#### `button'`

``` purescript
button' :: forall i. [HTML i] -> HTML i
```


#### `div`

``` purescript
div :: forall i. [Attribute i] -> [HTML i] -> HTML i
```


#### `div'`

``` purescript
div' :: forall i. [HTML i] -> HTML i
```



## Module Halogen.Signal

#### `Signal`

``` purescript
newtype Signal eff i o
```

A `Signal` represents a state machine which responds to inputs of type `i`, producing outputs of type `o`.

#### `runSignal`

``` purescript
runSignal :: forall i o eff. Signal eff i o -> i -> Eff eff (Signal1 eff i o)
```

Run a `Signal` by providing an input

#### `Signal1`

``` purescript
newtype Signal1 eff i o
```

`Signal1` represents non-empty signals, i.e. signals with an initial output value.

#### `runSignal1`

``` purescript
runSignal1 :: forall eff i o. Signal1 eff i o -> { next :: Signal eff i o, result :: o }
```

Run a `Signal1` to obtain the initial value and remaining signal

#### `input`

``` purescript
input :: forall eff i. Signal eff i i
```

A `Signal` which returns the latest input

#### `startingAt`

``` purescript
startingAt :: forall eff i o. Signal eff i o -> o -> Signal1 eff i o
```

Convert a `Signal` to a `Signal1` by providing an initial value

#### `head`

``` purescript
head :: forall eff i o. Signal1 eff i o -> o
```

Get the current value of a `Signal1`

#### `tail`

``` purescript
tail :: forall eff i o. Signal1 eff i o -> Signal eff i o
```

Convert a `Signal1` to a `Signal` by ignoring its initial value

#### `stateful`

``` purescript
stateful :: forall eff s i o. s -> (s -> i -> Eff eff s) -> Signal1 eff i s
```

Creates a stateful `Signal`

#### `functorSignal`

``` purescript
instance functorSignal :: Functor (Signal eff i)
```


#### `functorSignal1`

``` purescript
instance functorSignal1 :: Functor (Signal1 eff i)
```


#### `applySignal`

``` purescript
instance applySignal :: Apply (Signal eff i)
```


#### `applySignal1`

``` purescript
instance applySignal1 :: Apply (Signal1 eff i)
```


#### `applicativeSignal`

``` purescript
instance applicativeSignal :: Applicative (Signal eff i)
```


#### `applicativeSignal1`

``` purescript
instance applicativeSignal1 :: Applicative (Signal1 eff i)
```


#### `profunctorSignal`

``` purescript
instance profunctorSignal :: Profunctor (Signal eff)
```


#### `profunctorSignal1`

``` purescript
instance profunctorSignal1 :: Profunctor (Signal1 eff)
```


#### `semigroupoidSignal`

``` purescript
instance semigroupoidSignal :: Semigroupoid (Signal eff)
```


#### `categorySignal`

``` purescript
instance categorySignal :: Category (Signal eff)
```




